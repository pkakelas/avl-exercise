Εργασία στις Δομές Δεδομένων
Ον
Ονοματεπώνυμα:                              
ΑΕΜ:
Λαμπρινός Δημήτρης
2761
Πιτσινή Αναστασία-Ιωάννα
2793


  Η εργασία αυτή βασίζεται πάνω στα δυαδικά δέντρα, την υλοποίηση και την επεξεργασία τους στη γλώσσα C++. Όπως ήδη γνωρίζουμε, ένα δυαδικό δένδρο (binary tree) είναι μία πεπερασμένη συλλογή στοιχείων. Όταν το δυαδικό δένδρο δεν είναι κενό, τότε έχει μία ρίζα και τα υπόλοιπα στοιχεία (αν υπάρχουν) επιμερίζονται σε δύο επίσης δυαδικά δένδρα (το αριστερό και το δεξιό υποδένδρο του), ενώ ένα δυαδικό δένδρο καλείται δένδρο AVL αν και μόνο αν τα ύψη των δύο (αριστερού και δεξιού) κάθε εσωτερικού κόμβου διαφέρουν το πολύ κατά 1. Η εργασία απαιτεί την υλοποίηση ενός προγράμματος, το οποίο θα διαβάζει-ανοίγει ένα αρχείο, στο οποίο περιέχονται συνδεδεμένα IDs, τα οποία θα τοποθετεί ανάλογα με τις συνδέσεις τους σε AVL trees. Το πρόγραμμα, επίσης, πρέπει να υποστηρίζει τις λειτουργίες εισαγωγή και διαγραφή. 
  Αρχικά, συμπεριλαμβάνουμε στων κώδικα τις βιβλιοθήκες που μας είναι απαραίτητες για τη διαχείριση αρχείων, για εντολές, συναρτήσεις κ.ο.κ. Δημιουργούμε μία κλάση, με όνομα TreeNode, η οποία αφορά όλες τις λειτουργίες που θα γίνουν πάνω στα δέντρα (στην ουσία περιέχει όλα τα στοιχεία-εργαλεία που υλοποιούν και επεξεργάζονται δέντρα). Δηλώνουμε δημόσιες μεταβλητές τους δείκτες για το δεξί και το αριστερό (κόμβο), το ύψος και την τιμή key. Έχουμε τον κατασκευαστή της κλάσης αρχικοποιεί (βάζει τιμές) στη τιμή key την τιμή value που δέχεται ως παράμετρο, ενώ στους right και left δείκτες βάζει την τιμή NULL, αφού αρχικά το δέντρο είναι κενό. Έπειτα, έχουμε τη συνάρτηση που επιτελεί τη λειτουργία της εισαγωγής με το όνομα insert. Με λίγα λόγια, αν η τιμή value που δέχεται ως παράμετρο είναι μικρότερη από τη τιμή key και το left είναι <<άδειο>> τότε δημιουργεί ένα αριστερό φύλο και δεσμεύει καινούριο χώρο στη μνήμη, αλλιώς αν το left δεν είναι <<άδειο>> (έχει δηλαδή κάποιο παιδί) τότε εκτελούμε την συνάρτηση insert για το left. Το αντίστοιχο συμβαίνει και για το right. Η συνάρτηση τελικά επιστρέφει τη τιμή της συνάρτησης balance, η οποία θα αναλυθεί παρακάτω. Έπειτα, έχουμε τη συνάρτηση  exportTreeData 
Παρακάτω, συντάσουμε τη συνάρτηση remove με ορίσματα έναν κόμβο και μια τιμή value. Η συνάρτηση αυτή υλοποιεί τη λειτουργία της διαγραφής. Ουσιαστικά, μεταφέρει το στοιχείο που θέλουμε να διαγράψουμε στο άκρο του δέντρου και το διαγράφουμε. Εάν τιμή value που δέχεται σαν παράμετρο είναι μικρότερη από τη τιμή κλειδί της κλάσης του δέντρου τότε καλούμε την ίδια συνάρτηση για τον αριστερό κόμβο και βάζουμε τη τιμή NULL. Το αντίστοιχο κάνουμε και για το δεξί σε περίπτωση που η τιμή value είναι μεγαλύτερη απο το key. Διαφορετικά, ορίζουμε τα nodeA, nodeB τύπου treeNode* και βάζουμε στον δείκτη nodeA το left και στο δείκτη nodeB το right. Μετά διαγράφουμε τον κόμβο με τη συγκεκριμένη τιμή. Όμως, αν το nodeB είναι <<κενό>> τότε η συνάρτηση επιστρέφει το nodeA. Ορίζουμε τη μεταβλητή min η οποία είναι δείκτης τύπου treeNode. Στο min εκχωρούμε την τιμή που επιστρέφει η συνάρτηση getMin για το nodeB (τη συνάρτηση getMin θα την αναλύσουμε παρακάτω).  Για το min που δείχνει στο right εκτελούμε τη συνάρτηση removeMin (αναλύεταια παρακάτω) στο nodeB και θέτουμε στο min του left το nodeA. Σε αυτή τη περίπτωση, επιστρέφουμε τη τιμή της συνάρτησης balance που εφαρμόζεται στο min που ορίσαμε. Σε κάθε άλλη περίπτωση, επιστρέφουμε τη τιμή της συνάρτησης balance για το node. Στη συνάρτηση countNodes, ουσιαστικά μετράμε  τους κόμβους που έχει το δέντρο. Ορίζουμε τη μεταβλητή count=1 και μετά τη μεταβάλουμε κατά 1 μία για το left ή το right καλώντας αναδρομικά τη συνάρτηση. Τώρα περνάμε στα private μέη της κλάσης. Η συνάρτηση balanceFactor επιστρέφει τη διαφορά ύψους του δεξιού και του αριστερού υπόδεντρου το αρχικού δέντρου. Οι ακέραιες μεταβλητές hRight και hLeft είναι τα ύψη του δεξιού και του αριστερού υπόδεντρου, αντίστοιχα, των οποίων τις τιμές τις πέρνουμε από την συνάρτηση getHeight που ορίζουμε πιο κάτω. Η getHeight, λοιπόν, βρίσκει το ύψος του δέντρου. Χρησημοποιηεί τις μεταβλητές hRight (αν το right δεν είναι NULL τότε τρέχει αναδρομικά την ίδια συνάρτηση, αλλιώς της βάζει τη τιμή 0) και hLeft (ορισμένη με τον αντίστοιχο τρόπο. Επίσης, χησιμοποιηεί τη μεταβλητή max η οποία παίρνει τη τιμή του hLeft αν αυτό είναι μεγαλύτερο του hRight, αλλιώς παίρνει τη τιμή του hRight. Η τιμή που επιστρέφει είναι αυτή του max αυξηένη κατά 1 (αφού μετράμε από τη ρίζα). Η συνάρτηση rotate κάνει περιστροφή των κόμβων είτε δεξιά είτε αριστερά. Δέχεται ως παράμετρο ένα string το οποίο καθορίζει από πια πλευρά θα γίνει περιστροφή. Θέτουμε το nodeB ως NULL. Αν το string δηλώνει δεξιά περιστροφή τότε περιστρέφουμε τον κόμβο προς τα δεξιά. Αν δηλώνει αριστερή περιστροφή τότε ο κόμβος περιστρέφεται στα αριστερά. Τελικά, η συνάρτηση επιστρέφει τον δείκτη nodeB. Επειδή τα AVL trees έχουν την ιδιότητα η διαφορά ύψους του δεξιού με το αριστερό υπόδεντρο να είναι το πολύ 1, πρέπει να ισορροπίσουμε το δέντρο, έπειτα τις αλλαγές που τυχόν επηρέασαν το ύψος του. Ορίζουμε μία μεταβλητή που είναι η τιμή της διαφοράς ύψους των 2 υποδέντρων. Αν η διαφορά τους είναι 2, σημαίνει ότι <<γέρνει>> προς τα δεξιά, επομένως εξετάζουμε αν η διαφορά ύψους για το right είναι μικρότερη του 0 και αν είναι τότε πρέπει να το κάνουμε περιστροφή στα δεξιά καλώντας τη συνάρτηση rotate. Επιστρέφουμε σε αυτή τη περίπτωση τον δείκτη που προκύπτει από την αριστερή περιστροφή. Από την άλλη πλευρά, αν η διαφορά τους είναι -2, θα γέρνει αριστερά. Ελέγχουμε αν η διαφορά για το left είναι θετική για να κάνουμε αριστερή περιστροφή. Επιστρέφουμε το δείκτη που προκύπτει από την δεξιά περιστροφή. Διαφορετικά, επιστρέφουμε το this (όπου εννοείται η τιμή key). Η συνάρτηση getMin βρίσκει το πιο μικρό στοιχείο του δέντρου το οποίο είναι το πιο αριστερό στοιχείο του. Έτσι χρησιμοποιούμε αναδρομικά τη συνάρτηση αυ΄τη μέχρι να φτάσουμε στο αριστερότερο στοιχείο το οποίο επιστρέφουμε. Η συνάρτησηση removeMin διαγράφει το στοιχείο που βρίσκεται στο άκρος του δέντρου. 
